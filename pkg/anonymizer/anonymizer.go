/*
 * Copyright 2024 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package anonymizer

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"regexp"
	"strings"

	"github.com/rotisserie/eris"

	"github.com/cloudwego/eino/components/model"
	"github.com/cloudwego/eino/components/prompt"
	"github.com/cloudwego/eino/schema"
)

// Anonymizer is the entity anonymization handler.
type Anonymizer struct {
	anonymizeTemplate *prompt.DefaultChatTemplate
	llm               model.BaseChatModel
}

// createAnonymizeMessages creates messages for anonymization.
func (a *Anonymizer) createAnonymizeMessages(ctx context.Context, types []string, text string) ([]*schema.Message, error) {
	encodedTypes, err := json.Marshal(types)
	if err != nil {
		return nil, eris.Wrap(err, "failed to marshal types")
	}

	messages, err := a.anonymizeTemplate.Format(ctx, map[string]any{
		"types": string(encodedTypes),
		"text":  text,
	})

	if err != nil {
		return nil, eris.Wrap(err, "failed to format message")
	}

	return messages, nil
}

// parseAnonymizeResponse parses the complete LLM response to extract anonymized text and entities.
// The response format is: <anonymized_text>\n<<<PAIR>>>\n<JSON_mapping>
func parseAnonymizeResponse(responseContent string) (string, []*Entity, error) {
	splited := strings.SplitN(responseContent, "<<<PAIR>>>", 2)
	if len(splited) != 2 {
		return "", nil, fmt.Errorf("invalid response format, expected 2 parts but got %d, %s", len(splited), responseContent)
	}

	anonymizedText := strings.TrimSpace(splited[0])
	mappingStr := strings.TrimSpace(splited[1])

	entities, err := parseAnonymizeEntities([]byte(mappingStr))
	if err != nil {
		return "", nil, err
	}

	return anonymizedText, entities, nil
}

// parseAnonymizeResponse parses the complete LLM response to extract anonymized text and entities.
func parseAnonymizeEntities(entitiesStr []byte) ([]*Entity, error) {

	var mapping map[string][]string
	err := json.Unmarshal(entitiesStr, &mapping)
	if err != nil {
		return nil, eris.Wrap(err, "failed to unmarshal mapping")
	}

	// key format: <EntityType[ID].Category.Detail>
	keyParseRe := regexp.MustCompile(`<(.+?)\[(.+?)\]\.(.+?)\.(.+?)>`)
	entities := make([]*Entity, 0, len(mapping))
	for key, values := range mapping {
		matches := keyParseRe.FindStringSubmatch(key)
		if len(matches) != 5 {
			return nil, fmt.Errorf("invalid key format: %s", key)
		}

		entityType := matches[1]
		id := matches[2]
		category := matches[3]
		detail := matches[4]

		entities = append(entities, &Entity{
			Key:        key,
			EntityType: entityType,
			ID:         id,
			Category:   category,
			Detail:     detail,
			Values:     values,
		})
	}

	return entities, nil
}

// AnonymizeTextStream anonymizes the given text with streaming output.
// It streams the anonymized text to the provided writer as tokens are generated by the LLM.
// The entities mapping is returned after the stream completes.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - types: Entity types to detect (e.g., ["个人信息", "业务信息"])
//   - text: Input text to anonymize
//   - writer: Destination for streaming output (e.g., os.Stdout, file, io.MultiWriter)
//
// Returns:
//   - entities: List of detected entities with their mappings
//   - error: Any error during streaming, writing, or parsing
//
// Example:
//
//	var buf bytes.Buffer
//	entities, err := anon.AnonymizeTextStream(ctx, types, input, &buf)
//	if err != nil {
//	    return err
//	}
//	fmt.Printf("Streamed output: %s\n", buf.String())
//	fmt.Printf("Entities: %+v\n", entities)
func (a *Anonymizer) AnonymizeTextStream(ctx context.Context, types []string, text string, writer io.Writer) ([]*Entity, error) {
	messages, err := a.createAnonymizeMessages(ctx, types, text)
	if err != nil {
		return nil, eris.Wrap(err, "failed to create anonymize messages")
	}

	// Get streaming reader from LLM
	streamReader, err := a.llm.Stream(ctx, messages)
	if err != nil {
		// Fallback to Generate if Stream is not supported (e.g., in tests)
		response, genErr := a.llm.Generate(ctx, messages)
		if genErr != nil {
			return nil, eris.Wrap(genErr, "failed to generate response (stream fallback)")
		}
		// Parse response to extract anonymized text and entities
		anonymizedText, entities, parseErr := parseAnonymizeResponse(response.Content)
		if parseErr != nil {
			return nil, eris.Wrap(parseErr, "failed to parse response")
		}
		// Write only the anonymized text to writer
		if _, writeErr := writer.Write([]byte(anonymizedText)); writeErr != nil {
			return nil, eris.Wrap(writeErr, "failed to write to output")
		}
		return entities, nil
	}

	var lineBuffer bytes.Buffer
	var entitiesBuffer bytes.Buffer // Entity JSON
	foundPair := false

	for {
		msg, err := streamReader.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, eris.Wrap(err, "failed to receive stream token")
		}

		if foundPair {
			// After <<<PAIR>>>, collect JSON tokens
			entitiesBuffer.WriteString(msg.Content)
			continue
		}

		lineBuffer.WriteString(msg.Content)
		if !strings.Contains(msg.Content, "\n") {
			continue
		} else if strings.Contains(lineBuffer.String(), "<<<PAIR>>>") {
			foundPair = true
			continue
		}

		_, err = writer.Write(lineBuffer.Bytes())
		if err != nil {
			return nil, eris.Wrap(err, "failed to write to output")
		}
		lineBuffer.Reset()
	}

	entities, err := parseAnonymizeEntities(entitiesBuffer.Bytes())
	if err != nil {
		return nil, eris.Wrap(err, "failed to parse anonymize response")
	}

	return entities, nil
}

// AnonymizeText anonymizes the given text based on the specified entity types.
// This method uses streaming internally but returns the complete result.
// For real-time streaming output, use AnonymizeTextStream instead.
func (a *Anonymizer) AnonymizeText(ctx context.Context, types []string, text string) (string, []*Entity, error) {
	var buf bytes.Buffer
	entities, err := a.AnonymizeTextStream(ctx, types, text, &buf)
	if err != nil {
		return "", nil, err
	}

	// The buffer contains the anonymized text written by AnonymizeTextStream
	// No need to parse again since entities are already returned
	return buf.String(), entities, nil
}

// RestoreText restores the original text from the anonymized text using the provided entities.
func (a *Anonymizer) RestoreText(ctx context.Context, entities []*Entity, text string) (string, error) {
	var replaceMapping []string
	for _, entity := range entities {
		if len(entity.Values) == 0 {
			continue
		}
		replaceMapping = append(replaceMapping, entity.Key, entity.Values[0])
	}

	replacer := strings.NewReplacer(replaceMapping...)
	return replacer.Replace(text), nil
}

// New creates a new Anonymizer instance.
func New(chatModel model.BaseChatModel) (*Anonymizer, error) {
	anonymizeTemplate := prompt.FromMessages(schema.FString,
		schema.UserMessage(`Anonymize the text with the given entity types, then output the tag-to-original mapping; if nothing is found, reply "None".
Specified types: {types}
<text>{text}</text>`),
	)

	return &Anonymizer{
		anonymizeTemplate: anonymizeTemplate,
		llm:               chatModel,
	}, nil
}
