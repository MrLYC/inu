/*
 * Copyright 2024 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package commands

import (
	"context"
	"fmt"
	"io"
	"os"

	"github.com/rotisserie/eris"
	"github.com/spf13/cobra"

	"github.com/mrlyc/inu/pkg/anonymizer"
	"github.com/mrlyc/inu/pkg/cli"
)

var (
	restoreFile     string
	restoreContent  string
	restoreEntities string
	restoreNoPrint  bool
	restoreOutput   string
)

// NewRestoreCmd creates the restore command.
func NewRestoreCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "restore",
		Short: "Restore anonymized text to original",
		Long: `Restore anonymized text using the entities file saved during anonymization.
Requires an entities YAML file generated by the anonymize command.`,
		RunE: runRestore,
	}

	flags := cmd.Flags()
	flags.StringVarP(&restoreFile, "file", "f", "", "Read anonymized text from file")
	flags.StringVarP(&restoreContent, "content", "c", "", "Anonymized text as string")
	flags.StringVarP(&restoreEntities, "entities", "e", "", "Entities YAML file (required)")
	flags.BoolVar(&restoreNoPrint, "no-print", false, "Do not print output to stdout (default: print to stdout)")
	flags.StringVarP(&restoreOutput, "output", "o", "", "Write restored text to file")

	_ = cmd.MarkFlagRequired("entities")

	return cmd
}

func runRestore(cmd *cobra.Command, args []string) error {
	ctx := context.Background()

	// Validate entities flag
	if restoreEntities == "" {
		return eris.New("--entities flag is required")
	}

	// Read input
	var stdin *os.File
	if restoreFile == "" && restoreContent == "" {
		stdin = os.Stdin
	}

	input, err := cli.ReadInput(restoreFile, restoreContent, stdin)
	if err != nil {
		return err
	}

	// Load entities
	cli.ProgressMessage("=== Loading entities from: %s ===", restoreEntities)
	entities, err := cli.LoadEntitiesFromYAML(restoreEntities)
	if err != nil {
		return err
	}

	// Initialize LLM (not needed for restore, but keep same pattern)
	llm, err := anonymizer.CreateOpenAIChatModel(ctx)
	if err != nil {
		return err
	}

	anon, err := anonymizer.NewHashHidePair(llm)
	if err != nil {
		return err
	}

	// Restore text
	cli.ProgressMessage("=== Restoring text... ===")

	// Create writer for output
	var writer io.Writer
	if restoreOutput != "" {
		// Create output file
		fileWriter, err := os.Create(restoreOutput)
		if err != nil {
			return eris.Wrapf(err, "failed to create output file: %s", restoreOutput)
		}
		defer func() {
			if err := fileWriter.Close(); err != nil {
				fmt.Fprintf(os.Stderr, "Warning: failed to close file: %v\n", err)
			}
		}()

		if restoreNoPrint {
			// Only write to file
			writer = fileWriter
		} else {
			// Write to both file and stdout
			writer = io.MultiWriter(os.Stdout, fileWriter)
		}
	} else if restoreNoPrint {
		// No output
		writer = io.Discard
	} else {
		// Only stdout
		writer = os.Stdout
	}

	failures, err := anon.RestoreText(ctx, entities, input, writer)
	if err != nil {
		return err
	}

	// Display warnings for failed placeholders
	if len(failures) > 0 {
		fmt.Fprintf(os.Stderr, "\nWarning: %d placeholder(s) could not be restored:\n", len(failures))
		for _, failure := range failures {
			var reasonMsg string
			if failure.Reason == "empty_values" {
				reasonMsg = "(entity has no values)"
			} else {
				reasonMsg = "(not found in entities file)"
			}
			fmt.Fprintf(os.Stderr, "  - %s %s\n", failure.Placeholder, reasonMsg)
		}
	}

	cli.ProgressMessage("=== Restoration complete ===")
	return nil
}
